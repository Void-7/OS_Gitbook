# 死锁

## 原理

### 定义

> 死锁定义为一组**相互竞争系统资源或进行通信**的进程间的“**永久**”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所有请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。因为没有事件能够被触发，故死锁是永久性的。与并发进程管理中的其他问题不同，死锁问题并无有效的通用解决方案。         ——《操作系统：精髓与设计原理》P164

简单地说：死锁\(Deadlock\)是指一组进程因**竞争资源**而造成的一种**僵局**\(Deadly Embrace\) ， 即每个进程都占有部分资源，同时又需得到已被该组进程中其他占用的资源，若无外力作用，这些进程都将永远处于等待状态。

### 举例

![&#x6B7B;&#x9501;&#x56FE;&#x793A;](../.gitbook/assets/qq-tu-pian-20210524192145%20%281%29.jpg)

所有死锁都涉及多进程间资源的竞争冲突。常见例子是交通死锁。四辆汽车同时达到十字路口并停下（如图a），交叉路口上的四个象限就是需要被控制的资源。四辆车都想要直线通过十字路口：向北的汽车1需要ab，向南的汽车3需要cd，向西的汽车2需要bc，向东的汽车4需要ld。

此时任何一辆汽车继续通行的资源都能被满足，但如果四辆车同时前行，就会出现图b的死锁情况。每辆汽车都占有一个象限而需要的另一个象限被旁边的车占有，它们都无法继续同行。



