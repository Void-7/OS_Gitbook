# 死锁

## 原理

### 定义

> 死锁定义为一组**相互竞争系统资源或进行通信**的进程间的“**永久**”阻塞。当一组进程中的每个进程都在等待某个事件（典型情况下是等待释放所有请求的资源），而仅有这组进程中被阻塞的其他进程才可触发该事件时，就称这组进程发生了死锁。因为没有事件能够被触发，故死锁是永久性的。与并发进程管理中的其他问题不同，死锁问题并无有效的通用解决方案。         ——《操作系统：精髓与设计原理》P164

简单地说：死锁\(Deadlock\)是指一组进程因**竞争资源**而造成的一种**僵局**\(Deadly Embrace\) ， 即每个进程都占有部分资源，同时又需得到已被该组进程中其他占用的资源，若无外力作用，这些进程都将永远处于等待状态。

### 举例

![&#x6B7B;&#x9501;&#x56FE;&#x793A;](../.gitbook/assets/qq-tu-pian-20210524192145%20%281%29.jpg)

所有死锁都涉及多进程间资源的竞争冲突。常见例子是交通死锁。四辆汽车同时达到十字路口并停下（如图a），交叉路口上的四个象限就是需要被控制的资源。四辆车都想要直线通过十字路口：向北的汽车1需要ab，向南的汽车3需要cd，向西的汽车2需要bc，向东的汽车4需要ld。

此时任何一辆汽车继续通行的资源都能被满足，但如果四辆车同时前行，就会出现图b的死锁情况。每辆汽车都占有一个象限而需要的另一个象限被旁边的车占有，它们都无法继续同行。

另外，哲学家进餐问题中所有哲学家都拿起同一侧的筷子，则所有人都拿着一根筷子，而需要的另一根在旁边的哲学家手上，导致所有人都无法进餐，永远阻塞。

### 死锁、死循环、饥饿

死锁：所有进程等待对方占有的资源而无法继续运行的阻塞现象。

饥饿：由于长期得不到所需资源，某进程无法继续运行的现象。如：SPJ算法中，如果不断有短进程到来，则长进程始终得不到处理机，进而发生长进程的“饥饿”。

死循环：某进程执行过程中一直不跳出某循环的现象。

![&#x6982;&#x5FF5;&#x533A;&#x522B;](../.gitbook/assets/image%20%282%29.png)

### 联合进程图

![joint progress diagram](../.gitbook/assets/image%20%281%29.png)

如上图，两个进程的联合进程图，展示了六条不同的路径（A、B是两个不同的资源）：

Q进程获得B，然后获得A，再释放B和A；当P进程恢复执行时，它可以获得全部的资源； Q进程获得B，然后获得A；P进程开始执行但阻塞在对A的请求上；Q进程释放B和A；当P进程恢复执行时它可以获得全部资源； Q进程获得B，然后P进程获得A；Q继续执行但阻塞在对A的请求上；P进行继续执行但阻塞在对B的请求上，构成死锁； P进程获得A，然后Q进程获得B；Q继续执行但阻塞在对A的请求上；P进程继续执行但阻塞在对B的请求上，构成死锁； P进程获得A，然后获得B；Q进程开始执行但阻塞在对B的请求上；P释放A和B；当Q进程恢复执行时可获得全部资源； P进程获得A，然后获得B，再释放A和B；当Q进程恢复执行时可以获得全部资源。 

出处：[https://blog.csdn.net/d5\_\_j9/article/details/90552063](https://blog.csdn.net/d5__j9/article/details/90552063)



